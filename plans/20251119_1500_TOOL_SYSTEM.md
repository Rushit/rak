# RAK Tool System Documentation

**Created:** 2025-11-19 15:00  
**Last Updated:** 2025-11-19 15:00  
**Status:** Phase 2 Complete

## Purpose

This document provides comprehensive documentation for the RAK tool system, including usage examples, API reference, and implementation details.

---

## Overview

The tool system enables LLM agents to perform actions beyond text generation by executing functions, calling APIs, and interacting with external systems. Tools are automatically called by the LLM when needed and their results are fed back into the conversation.

### Key Features

- **Function-based tools**: Create tools from async functions
- **Automatic schema generation**: JSON schemas generated from Rust types
- **Streaming integration**: Tools execute seamlessly within agent event streams
- **Built-in tools**: Calculator, echo, and more out of the box
- **Type-safe**: Leverage Rust's type system for tool parameters
- **Error handling**: Robust error handling and recovery

---

## Quick Start

### 1. Creating a Simple Tool

```rust
use rak_tool::{FunctionTool, ToolSchema};
use rak_core::{ToolResponse, Result};

// Create a tool using the builder
let greeter = FunctionTool::builder()
    .name("greet")
    .description("Greets a person by name")
    .schema(
        ToolSchema::new()
            .property("name", "string", "The person's name")
            .required("name")
            .build()
    )
    .execute(|_ctx, params| async move {
        let name = params["name"].as_str().unwrap_or("stranger");
        Ok(ToolResponse {
            result: serde_json::json!({
                "greeting": format!("Hello, {}!", name)
            }),
        })
    })
    .build()?;
```

### 2. Adding Tools to an Agent

```rust
use rak_agent::LLMAgent;
use rak_tool::builtin::create_calculator_tool;
use std::sync::Arc;

let calculator = Arc::new(create_calculator_tool()?);

let agent = LLMAgent::builder()
    .name("assistant")
    .description("A helpful assistant")
    .model(model)
    .tool(calculator)  // Add single tool
    .build()?;
```

### 3. Adding Multiple Tools

```rust
use rak_tool::builtin::{create_calculator_tool, create_echo_tool};

let tools = vec![
    Arc::new(create_calculator_tool()?),
    Arc::new(create_echo_tool()?),
];

let agent = LLMAgent::builder()
    .name("assistant")
    .model(model)
    .tools(tools)  // Add multiple tools
    .build()?;
```

---

## Architecture

### Tool Execution Flow

```
┌──────────────┐
│     User     │
│   Message    │
└──────┬───────┘
       │
       ▼
┌─────────────────────────────────────────┐
│           LLMAgent                      │
│  ┌────────────────────────────────┐    │
│  │  1. Send message to LLM        │    │
│  └─────────┬──────────────────────┘    │
│            ▼                            │
│  ┌────────────────────────────────┐    │
│  │  2. LLM returns function call  │    │
│  └─────────┬──────────────────────┘    │
│            ▼                            │
│  ┌────────────────────────────────┐    │
│  │  3. Execute tool               │    │
│  │     - Find tool by name        │    │
│  │     - Create tool context      │    │
│  │     - Call tool.execute()      │    │
│  └─────────┬──────────────────────┘    │
│            ▼                            │
│  ┌────────────────────────────────┐    │
│  │  4. Return result to LLM       │    │
│  └─────────┬──────────────────────┘    │
│            ▼                            │
│  ┌────────────────────────────────┐    │
│  │  5. LLM processes result       │    │
│  │     and generates response     │    │
│  └────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

### Core Components

#### 1. **Tool Trait** (`rak-core`)

```rust
#[async_trait]
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn schema(&self) -> serde_json::Value;
    fn is_long_running(&self) -> bool { false }
    
    async fn execute(
        &self,
        ctx: Arc<dyn ToolContext>,
        params: serde_json::Value,
    ) -> Result<ToolResponse>;
}
```

#### 2. **FunctionTool** (`rak-tool`)

A flexible implementation of the Tool trait that wraps async functions.

```rust
pub struct FunctionTool {
    name: String,
    description: String,
    schema: Value,
    is_long_running: bool,
    execute_fn: ToolFn,
}
```

#### 3. **ToolContext**

Provides context information during tool execution:

```rust
pub trait ToolContext: Send + Sync {
    fn function_call_id(&self) -> &str;
    fn invocation_id(&self) -> &str;
}
```

---

## API Reference

### FunctionTool Builder

```rust
FunctionTool::builder()
    .name("tool_name")              // Required: Tool identifier
    .description("What it does")    // Required: Tool description
    .schema(schema)                 // Optional: JSON schema
    .long_running(false)            // Optional: Is long-running
    .execute(|ctx, params| async {  // Required: Execution function
        // Implementation
    })
    .build()
```

### ToolSchema Builder

```rust
ToolSchema::new()
    .property("param1", "string", "Description")
    .property("param2", "number", "Another param")
    .required("param1")
    .build()
```

### Schema Generation from Types

```rust
use schemars::JsonSchema;
use rak_tool::generate_schema;

#[derive(JsonSchema)]
struct CalculatorParams {
    expression: String,
}

let schema = generate_schema::<CalculatorParams>();
```

---

## Built-in Tools

### Calculator Tool

Evaluates mathematical expressions.

```rust
use rak_tool::builtin::create_calculator_tool;

let calculator = create_calculator_tool()?;

// Usage example
let params = serde_json::json!({
    "expression": "10 + 5 * 2"
});
let result = calculator.execute(ctx, params).await?;
// Result: {"result": 20.0, "expression": "10 + 5 * 2"}
```

**Supported operations:**
- Basic arithmetic: `+`, `-`, `*`, `/`
- Parentheses: `(`, `)`
- Numbers: integers and floats

### Echo Tool

Returns the input message (useful for testing).

```rust
use rak_tool::builtin::create_echo_tool;

let echo = create_echo_tool()?;

// Usage example
let params = serde_json::json!({
    "message": "Hello, World!"
});
let result = echo.execute(ctx, params).await?;
// Result: {"message": "Hello, World!", "invocation_id": "...", "function_call_id": "..."}
```

---

## Advanced Usage

### Custom Tool Implementation

```rust
use rak_core::{Tool, ToolContext, ToolResponse, Result};
use async_trait::async_trait;

struct WeatherTool {
    api_key: String,
}

#[async_trait]
impl Tool for WeatherTool {
    fn name(&self) -> &str {
        "get_weather"
    }
    
    fn description(&self) -> &str {
        "Gets current weather for a location"
    }
    
    fn schema(&self) -> serde_json::Value {
        serde_json::json!({
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City name or coordinates"
                }
            },
            "required": ["location"]
        })
    }
    
    async fn execute(
        &self,
        ctx: Arc<dyn ToolContext>,
        params: serde_json::Value,
    ) -> Result<ToolResponse> {
        let location = params["location"].as_str()
            .ok_or_else(|| Error::Other(anyhow::anyhow!("Missing location")))?;
        
        // Call weather API
        let weather = fetch_weather(&self.api_key, location).await?;
        
        Ok(ToolResponse {
            result: serde_json::json!({
                "temperature": weather.temp,
                "condition": weather.condition,
                "location": location
            }),
        })
    }
}
```

### Long-Running Tools

For tools that take significant time:

```rust
let long_tool = FunctionTool::builder()
    .name("process_data")
    .description("Processes large dataset")
    .long_running(true)  // Mark as long-running
    .execute(|ctx, params| async move {
        // Long operation
        tokio::time::sleep(Duration::from_secs(30)).await;
        
        Ok(ToolResponse {
            result: serde_json::json!({"status": "complete"}),
        })
    })
    .build()?;
```

### Tool Error Handling

Tools should return proper errors:

```rust
.execute(|ctx, params| async move {
    let value = params["value"].as_i64()
        .ok_or_else(|| Error::Other(anyhow::anyhow!("Invalid value parameter")))?;
    
    if value < 0 {
        return Err(Error::Other(anyhow::anyhow!("Value must be positive")));
    }
    
    Ok(ToolResponse {
        result: serde_json::json!({"processed": value * 2}),
    })
})
```

---

## Event Streaming

Tools integrate seamlessly with agent event streaming:

```rust
let mut stream = runner.run(user_id, session_id, message, config).await?;

while let Some(result) = stream.next().await {
    let event = result?;
    
    if let Some(content) = &event.content {
        for part in &content.parts {
            match part {
                Part::Text { text } => {
                    println!("Text: {}", text);
                }
                Part::FunctionCall { function_call } => {
                    println!("Calling tool: {}", function_call.name);
                    println!("Args: {}", function_call.args);
                }
                Part::FunctionResponse { function_response } => {
                    println!("Tool result: {}", function_response.response);
                }
                _ => {}
            }
        }
    }
}
```

### Event Types

1. **User Message Event**: Initial user input
2. **Model Response Event**: LLM decides to call a tool
3. **Function Call Event**: Contains the function call details
4. **Function Response Event**: Tool execution result
5. **Final Response Event**: LLM's final answer using tool results

---

## Testing Tools

### Unit Testing Tools

```rust
#[tokio::test]
async fn test_calculator() {
    let tool = create_calculator_tool().unwrap();
    
    let ctx = Arc::new(DefaultToolContext::new(
        "call-123".to_string(),
        "inv-456".to_string(),
    ));
    
    let params = serde_json::json!({
        "expression": "5 + 3"
    });
    
    let response = tool.execute(ctx, params).await.unwrap();
    assert_eq!(response.result["result"], 8.0);
}
```

### Integration Testing

```rust
#[tokio::test]
async fn test_agent_with_tools() {
    // Create mock LLM that returns function calls
    let model = Arc::new(MockLLM::new());
    
    let agent = LLMAgent::builder()
        .name("test")
        .model(model)
        .tool(Arc::new(create_calculator_tool()?))
        .build()?;
    
    let ctx = Arc::new(MockContext::new());
    let mut stream = agent.run(ctx).await;
    
    // Verify tool was called and response generated
    let events: Vec<_> = stream.collect().await;
    assert!(events.iter().any(|e| /* has function call */));
    assert!(events.iter().any(|e| /* has function response */));
}
```

---

## Best Practices

### 1. Tool Naming

- Use lowercase with underscores: `get_weather`, `calculate`, `search_web`
- Be descriptive but concise
- Avoid generic names like `tool1`, `function`

### 2. Descriptions

- Write clear, concise descriptions
- Explain what the tool does and when to use it
- Include examples if helpful

```rust
.description("Searches the web for information. Use when the user asks about current events, facts, or information not in your knowledge base.")
```

### 3. Schema Design

- Mark required parameters explicitly
- Provide meaningful parameter descriptions
- Use appropriate types (`string`, `number`, `boolean`, `object`, `array`)

### 4. Error Messages

- Provide helpful error messages
- Include context about what went wrong
- Suggest fixes when possible

```rust
Err(Error::Other(anyhow::anyhow!(
    "Failed to parse expression '{}': {}. Please use valid math operators (+, -, *, /)",
    expr, e
)))
```

### 5. Performance

- Keep tool execution fast (< 1 second ideally)
- Use `long_running(true)` for slow operations
- Consider caching for expensive operations
- Use timeouts to prevent hanging

---

## Troubleshooting

### Tool Not Being Called

**Problem**: Agent doesn't call the tool even when it should.

**Solutions**:
- Ensure tool description clearly indicates when to use it
- Add the tool to the agent with `.tool()`
- Verify the LLM supports function calling
- Check that parameters match the schema

### Tool Execution Fails

**Problem**: Tool returns an error during execution.

**Solutions**:
- Check parameter validation in `execute()`
- Add detailed error logging
- Verify external dependencies (APIs, files, etc.)
- Test the tool in isolation first

### Infinite Tool Loop

**Problem**: Agent keeps calling tools without finishing.

**Solutions**:
- Check `turn_complete` flag in LLM responses
- Verify tool responses are properly formatted
- Ensure tools return meaningful results
- The agent has a max iteration limit (default: 10)

---

## Examples

### Example 1: Simple Calculator Agent

```rust
use rak_agent::LLMAgent;
use rak_tool::builtin::create_calculator_tool;

let agent = LLMAgent::builder()
    .name("calc_bot")
    .model(model)
    .system_instruction("You help with math. Use the calculator tool for calculations.")
    .tool(Arc::new(create_calculator_tool()?))
    .build()?;
```

### Example 2: Multi-Tool Agent

```rust
let tools = vec![
    Arc::new(create_calculator_tool()?),
    Arc::new(create_search_tool()?),
    Arc::new(create_weather_tool()?),
];

let agent = LLMAgent::builder()
    .name("assistant")
    .model(model)
    .tools(tools)
    .build()?;
```

### Example 3: Custom Database Tool

```rust
let db_query = FunctionTool::builder()
    .name("query_database")
    .description("Queries the user database")
    .schema(
        ToolSchema::new()
            .property("query", "string", "SQL query to execute")
            .required("query")
            .build()
    )
    .execute(move |ctx, params| {
        let pool = db_pool.clone();
        async move {
            let query = params["query"].as_str()
                .ok_or_else(|| Error::Other(anyhow::anyhow!("Missing query")))?;
            
            let rows = sqlx::query(query)
                .fetch_all(&pool)
                .await?;
            
            Ok(ToolResponse {
                result: serde_json::to_value(rows)?,
            })
        }
    })
    .build()?;
```

---

## Future Enhancements

### Planned for Phase 2+

1. **Procedural Macros**: `#[tool]` attribute for easier tool creation
2. **More Built-in Tools**: 
   - Web search
   - Code execution
   - File operations
   - HTTP requests
3. **Tool Approval**: Human-in-the-loop for sensitive operations
4. **Tool Chaining**: Tools that call other tools
5. **Tool Marketplace**: Shareable tool packages

---

## API Summary

### Core Traits

- `Tool` - Base trait for all tools
- `ToolContext` - Context during tool execution

### Structs

- `FunctionTool` - Function-based tool implementation
- `ToolSchema` - Schema builder
- `DefaultToolContext` - Default context implementation
- `ToolResponse` - Tool execution result

### Functions

- `create_calculator_tool()` - Creates calculator tool
- `create_echo_tool()` - Creates echo tool
- `generate_schema<T>()` - Generates schema from type

---

## See Also

- [Implementation Summary](./20251119_1400_IMPLEMENTATION_SUMMARY.md)
- [Project Scope](./20251119_1410_PROJECT_SCOPE.md)
- [Testing Guide](./20251119_1425_TESTING_GUIDE.md)
- [API Documentation](./20251119_1435_DOCUMENTATION_INDEX.md)

---

**Document Version**: 1.0  
**Status**: Phase 2 Complete  
**Last Updated**: November 19, 2024

